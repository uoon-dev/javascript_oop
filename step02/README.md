# 2강
* 서브루틴 체인이 일어날 때 서브루틴은 미니 메모리를 갖게 되는데 미니 메모리 안에는 인자와 변수들이 있다. 자바스크립트 엔진에서 이를 실행 컨텍스트라고 부른다.
* 꼬리물기 최적화 : 서브루틴이 체이닝 된 상태일 때 서브루틴의 함수가 실행되면 메모리를 유지시키지 않고 리턴포인트를 메인 플로우의 포인트로 지정해줘서 모든 리턴 포인트가 동일한 지점을 가리키도록 꼬리물기를 하는 최적화 기법을 의미한다. 이는 제어문에서 for 문을 돌 때와 유사하다. for 문은 블록의 코드 실행이 끝나면 메모리를 유지시키지 않고 해제한다. 이를 제어문의 스택 클리어라고 부른다.  

## 예제1
```js
const sum = v => v + (v > 1 ? sum(v - 1) : 0);
sum(3);
```

* 위 예제에서 연산자는 꼬리물기 최적화를 방해한다. 메모리를 기억해야 연산을 실행시켜야 하기 때문이다. 
* 모든 연산자는 스택 메모리를 유발한다고 보면 된다.
 
## 예제2
```js
const sum = (v, prev = 0) => {
  prev += v;
  return (v > 1 ? sum(v - 1, prev) : prev);
};
sum(3);

``` 

* 위 예제는 인자 쪽에 연산을 넘겨버렸다. 자바스크립트에서 &, ||, 삼항연산자는 Tail Recursion을 일으키지 않는 예외적인 연산자다. 
* 꼬리물기 최적화가 안되어 있는 꼬리물기를 최적화시키는 위해선 연산을 인자로 밀어버리면 된다. 

## 예제3
```js
const sum = (v) => {
  let prev = 0;
  while(v > 1) {
    prev += v;
    v--;
  }
  return prev;
};
sum(3);

``` 

* 예제2는 결국 예제3으로 가는 것과 같다. 스칼라로 예제2처럼 짜면 자바로 예제3으로 번역이 되는 것이다.


# Closure

* 람다는 루틴을 값으로 보는 기술이다. 이는 C언어의 함수 포인터라는 기술로부터 발전되었다. 런타임에 드디어 서브루틴을 만들 수 있게 된 것이다. 클로저는 런타임 중에 루틴을 만들 수 있는 언어에서만 생성된다. 정적인 문법의 C에선 안 생긴다. 함수(루틴) 값이 아닌 문으로 만드는 애들의 특징이기도 하다.  
* 자바스크립트도 처음부터 함수가 존재하는 게 아니라 런타임 중에 함수가 태어난다. 메인 플로어 안에서 루틴이 만들어지는 것이다. 그 루틴 박스 안에 있는 로컬 변수와 인자들을 제외한 나머지 바깥의 변수들을 자유 변수라 부른다. 이 바깥에 있는 자유 변수들이 루틴 때문에 해제가 안되는데 이것이 바로 Free Variables Clousure 줄여서 Clousure다. 물론 런타임 중에 루틴을 만든다고 꼭 자유변수를 참조할 수 있게 언어가 디자인되는 건 아니다. 클로저가 없는 언어도 있다. 그래도 대부분은 클로저가 있다고 보면 된다.
* 루틴이 태어나는 환경을 컨텍스트라고 부른다. 

## 예제
```js
window.a = 3;
if (a == 3) {
  const b = 5;
  const f1 = v => {
    const c = 7;
    if (a + b > c) { 
      return p => v + p + a + b + c;
    } else {
      return p => v + p + a + b;
    }
  }
}
```

## Shadowing
```js
const a = 3;
if (a == 3) {
  const a = 5;
  const f1 = v => {
    const a = 7;
    console.log(a);
  }
}
```

* 쉐도잉은 언어에서 채택하는 경우도 있고 아닌 경우도 있다. 쉐도잉은 중첩된 클로저에서 이름이 겹치는 변수가 선언되어 있을 때 발생한다. 기본적으로 쉐도잉이 발생하면 가장 가까운 클로저의 영역 내에서 변수를 찾는다. 쉐도잉은 네임스페이스를 정의할 때 사용된다. 루틴 안쪽에 있는 코드는 바깥 쪽에 있는 자유 변수를 얼마든지 오염시킬 수 있다. 자유 변수를 보호하는 유일한 방법은 쉐도잉을 거는 것이다.   

#Co Routine
* es6부턴 내가 작성한 모든 문이 레코드라는 객체에 의해 감싸진다. 그리고 그 레코드가 하나 하나를 실행시키는 것이다. 이를 도입하면서 자바스크립트도 코루틴을 사용할 수 있게된 것이다. 한번 호출해서 한번 리턴하는 걸 싱클 루틴이라고 한다면 여러번 호출해서 여러번 리턴하는 걸 코 루틴이라고 한다. 
* 플로우가 진행되다가 코루틴에 의해서 멈춰있는 상태를 서스펜션이라고 부른다. yield에서 서스펜션을 걸어두고 메인 플로우로 넘어가서 다시 서브 루틴을 실행하면 아까 걸어둔 yield 이후를 실행한다. 서스펜션 블록을 활용해 몇번이고 진입했다가 나갔다가를 반복할 수 있다. 원래는 문은 중간에 멈출 방법이 없다. 근데 서스펜션을 사용하면 가능하다.
* 점점 공유해야할 데이터가 많아지면 받아서 다음 번 루틴에 인자를 넘겨주는 게 쉽지 않다. 그러나 코루틴을 이용하면 메모리가 해제되지 않기 때문에 상태유지가 지역변수를 통해 일어나 데이터를 공유할 수 있다는 장점이 있다.  

```js
const generator = function*(a) {
  a++;
  yield a;
  a++;
  yield a;
  a++;
  yield a;
};
const coroutine = generator(3);

let result = 0;
result += coroutine.next().value;
console.log(result); // 4
result += coroutine.next().value;
console.log(result); // 9
result += coroutine.next().value;
console.log(result); // 15
```

* 제너레이터를 호출한 결과 값이 코루틴이다. 코루틴을 만들어주는 애가 제너레이터다. 