# 2강
* 서브루틴 체인이 일어날 때 서브루틴은 미니 메모리를 갖게 되는데 미니 메모리 안에는 인자와 변수들이 있다. 자바스크립트 엔진에서 이를 실행 컨텍스트라고 부른다.
* 꼬리물기 최적화 : 서브루틴이 체이닝 된 상태일 때 서브루틴의 함수가 실행되면 메모리를 유지시키지 않고 리턴포인트를 메인 플로우의 포인트로 지정해줘서 모든 리턴 포인트가 동일한 지점을 가리키도록 꼬리물기를 하는 최적화 기법을 의미한다. 이는 제어문에서 for 문을 돌 때와 유사하다. for 문은 블록의 코드 실행이 끝나면 메모리를 유지시키지 않고 해제한다. 이를 제어문의 스택 클리어라고 부른다.  

## 예제1
```js
const sum = v => v + (v > 1 ? sum(v - 1) : 0);
sum(3);
```

* 위 예제에서 연산자는 꼬리물기 최적화를 방해한다. 메모리를 기억해야 연산을 실행시켜야 하기 때문이다. 
* 모든 연산자는 스택 메모리를 유발한다고 보면 된다.
 
## 예제2
```js
const sum = (v, prev = 0) => {
  prev += v;
  return (v > 1 ? sum(v - 1, prev) : prev);
};
sum(3);

``` 

* 위 예제는 인자 쪽에 연산을 넘겨버렸다. 자바스크립트에서 &, ||, 삼항연산자는 Tail Recursion을 일으키지 않는 예외적인 연산자다. 
* 꼬리물기 최적화가 안되어 있는 꼬리물기를 최적화시키는 위해선 연산을 인자로 밀어버리면 된다. 

## 예제3
```js
const sum = (v) => {
  let prev = 0;
  while(v > 1) {
    prev += v;
    v--;
  }
  return prev;
};
sum(3);

``` 

* 예제2는 결국 예제3으로 가는 것과 같다. 스칼라로 예제2처럼 짜면 자바로 예제3으로 번역이 되는 것이다.
